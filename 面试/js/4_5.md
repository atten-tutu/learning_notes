(1)全局作用域、函数作用域
最外层函数、最外层函数外面定义的变量都拥有全局作用域
未定义、直接赋值的变量自动声明为全局作用域
window对象的属性全局作用域
(2)函数作用域
声明在函数内部
内部可以访问外层、外层不能访问内层
(3)块级作用域（大括号作用域）
let、const,没有变量提升，不可以重复声明
原型
每一个函数都有prototype属性，默认指向object空对象（没有一些方法，也叫做原型对象，原型对象就是为实例对象存放共有属性和公有方法）
手动加属性：fun.prototype.test = function()，放在空对象里
原型对象有一个属性constructor,指向函数
[图片]
 原型对象添加的属性，给实例对象使用。实例对象可以直接使用
显式原型（每个函数的prototype）和隐式原型(每个实例对象的__proto__)
隐式原型的值是显式原型的值
由于显式原型默认指向一个空的object对象，隐式原型也指向那个obj
[图片]
[图片]

[图片]
现在自己身上找，找不到再到隐式原型找
程序员操作的是：显式原型
原型链
实例对象都有隐式原型·属性
[图片]

[图片]
[图片]

[图片]
找方法：先在自身属性查找，没有就沿着__proto__链找，最后再没找到，返回undefined
为什么有原型链
为了实现继承关系，是js实现面向对象的基础
当对象本身没有某个属性或方法时，通过__proto__向原型对象查找
所有实例共享构造函数原型上的方法
闭包
定义
1. 嵌套的内部函数引用了嵌套的外部函数的变量，就产生了闭包
2. 闭包是嵌套的内部函数，存在于嵌套的内部函数中
3. 产生条件：内部函数引用外部函数数据（变量/函数），执行函数定义就会产生闭包，不用调用内部函数
常用的闭包
1. 函数作为另一个函数的返回值
这个f是fn2啦
[图片]
2. 函数作为实参传递给另一个函数
[图片]
闭包的作用
1. 函数外部间接访问函数内部的数据（局部变量/函数）
2. 局部变量在函数执行完后，仍然存在内存中，延长了局部变量的生命周期
3. 如果希望外部只对内部数据读，或者只写，就通过闭包
4. 闭包不消失的原因：函数被return,变量存着
闭包的生命周期
1. 定义执行完就产生闭包
2. 嵌套的内部函数称为垃圾对象，闭包死亡（引用他的函数不再引用他了）